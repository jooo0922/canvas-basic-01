'use strict';

const canvas1 = document.querySelector(".canvas1");
const canvas2 = document.querySelector(".canvas2");
const context1 = canvas1.getContext("2d");
const context2 = canvas2.getContext("2d");

// 지금 두 개의 캔버스에 중심점이 (x, y) = (100, 100)에 위치하고, 반지름이 50px인 원을 똑같이 그려넣은 것.
// 그니까 지금 css로 크기만 똑같이 맞춰놨을 뿐 좌표값부터가 엄연히 다름. 중심점의 위치가 아예 다르잖아.
context1.arc(100, 100, 50, 0, Math.PI * 2, false);
context2.arc(100, 100, 50, 0, Math.PI * 2, false);
context1.fill();
context2.fill();

// 그런데 일부러 이렇게 사이즈를 2배로 설정해놓고 css로 절반 줄여서 표현해서 사용하는 경우도 많음.
// 왜냐고? Retina Display! 고해상도 디스플레이를 고려해서 픽셀 집적도를 높이려고 하는거임! 선명한 고해상도 이미지를 표현하려고!
// 우리가 포토샵으로 가로 300짜리 이미지를 만든다고 하면 실제로는 600정도로 만든 다음 css로 절반을 줄여서 표현하는거랑 같은거임.

// 그리고 일반적으로 캔버스는 Full Screen으로 꽉 채워서 사용하는 경우가 많음. 이럴땐 어떻게 해야할까?
// 자바스크립트로 캔버스의 width, height을 window size의 2배로 세팅해 놓은 다음, css에서는 100%로 맞추면 되겠지!
// 이렇게 하면 원래 캔버스 크기는 가로 * 세로가 브라우저의 2배가 될거고, 얘들을 css로 브라우저 크기만큼 줄여서 표한다는 것이지

// 그럼 무조건 캔버스 2배로 해서 레티나 디스플레이에 맞춰서 쓰는 게 좋겠네? 그치만 마냥 좋지도 않음.
// 크기 2배 = 픽셀 2배 = 계산할 픽셀의 수 2배 이기 때문임. 그만큼 연산할 일이 더 많아지고, 성능은 떨어지게 되는 것.
// 그래서 이런 부분들을 잘 고려해서 조절해줘야 함.
// 극단적으로 성능을 올려야 하는 앱인지, 아니면 미려하고 예쁘게, 선명하게 보이는게 중요한건지.
// 근데 요즘엔 하드웨어가 워낙 좋아져서 연산할 것이 어마어마하게 많지 않다 하면 그냥 크게 만든 다음 css로 줄여서 표시하면 예쁘게 나오긴 함.
// 특히 Apple 웹사이트 같은 경우 제품 사진이 정말 중요하기 때문에, 앞서 말한것처럼 캔버스를 크게 만들고 css로 줄여서 사용하는 게 많음.